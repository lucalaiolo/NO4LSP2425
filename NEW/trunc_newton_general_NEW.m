function [xk, fk, gradfk_norm, bcktrck_fail, k, xseq, btseq, flag, pcg_iterseq_mean] = ...
    trunc_newton_general_NEW(x0, f, gradf, Hessf, kmax, tolgrad, pcg_maxit, ...
        fterms, c1, rho, btmax, FDgrad, FDHess, h, adapt, build_efficient_grad, ...
        approx_grad, use_Hess_sparsity, approx_Hess)
% TRUNCATED NEWTON METHOD WITH BACKTRACKING
%
% INPUTS
% x0: column vector of n elements, starting point
% f: function handle to be minimized
% gradf: function handle representing the gradient of f
% Hessf: function handle representing the hessian of f
% kmax: maximum number of iterations allowed
% tolgrad: gradient tolerance 
% pcg_maxit: maximum number of iterations for pcg solver
% fterms: forcing terms for the inexact newton method
% c1: factor c1 for the Armijo condition
% rho: factor less than 1, used to reduce alpha (fixed, for simplicity)
% btmax: maximum number of backtracks
% FDgrad: string that if it is 'fw' or 'c' the newton method will use the
%   corresponding methods to approximate the gradient. Otherwise, 
%   the function handle gradf is used. 
% FDHess: string that if it is 'fw' or 'c' the newton method will use the
%   corresponding methods to approximate the hessian (not recommended for
%   large scale problems since it does not exploit the structure of the 
%   function) If it is 'MF', matrix free implementation. 
%   Otherwise, the function handle Hessf is used.
% h: finite differences "step"
% adapt: boolean value. To understand more about this, read findiff_grad
% build_efficient_grad: boolean value. If true, the approximation of the
%   gradient will be done using the function handle approx_grad.
% approx_grad: function handle PROBLEM DEPENDENT
% use_Hess_sparsity: boolean value. If true, the approximation of the Hessian
%   will be done using the function handle build_sparse_Hessf. IMPORTANT:
%   IF WE WANT TO USE A MATRIX-FREE METHOD (case FDHess = 'MF') THIS
%   PARAMETER MUST BE SET TO FALSE (since we are not actually building the
%   Hessian matrix) !!!!!! 
% approx_Hess: function handle that takes as input gradf (or an
%   approximation of it), x (column vector in R^n) and h and returns an
%   approximation of the Hessian of f computed at x and stored as a sparse
%   matrix (RECOMMENDED FOR LARGE SCALE PROBLEMS) (this function is PROBLEM
%   DEPENDENT)
%
% OUTPUTS
% xk: last vector xk computed by the iterative method
% fk: value of function f at xk
% gradfk_norm: norm of the gradient of f computed at xk
% k: index value of the last step executed by the method before stopping
% bcktrck_fail: boolean value. If true, this means that the method exited
%   because it did not find a suitable steplength during the backtracking
%   procedure
% xseq: matrix n-times-k whose column j is the j-th vector generated by
%   the method
% btseq: row vector of length k that contains the number of backtracks
%   at each step
% flag: extra output variable (string) describing failure or convergence
%   of  the method (and the reasons if there is no convergence)
% pcgiterseq: mean number of pcg-iterations executed at each main 
%   iteration for computing the direction

if build_efficient_grad
    gradf = @(x) approx_grad(x);
else
    switch FDgrad
        case 'fw'
            % OVERWRITE gradf WITH F. HANDLE THAT USES findiff_grad
            % [with option 'fw']
            gradf = @(x) findiff_grad(f, x, h, 'fw', adapt);
        case 'c'
            % OVERWRITE gradf WITH F. HANDLE THAT USES findiff_grad
            % [with option 'c']
            gradf = @(x) findiff_grad(f, x, h, 'c', adapt);
    end
end

if use_Hess_sparsity
    Hessf = @(x) approx_Hess(gradf, x);
    % !!! IF WE WANT TO USE A MATRIX-FREE METHOD, THIS PARAMETER MUST BE
    % SET TO FALSE !!!
else
    % General purpose finite differencing OR Matrix-free implementation
    % (recommended for very large scale problems)
    switch FDHess
        case 'c'
            % OVERWRITE Hessf WITH F. HANDLE THAT USES findiff_Hess
            Hessf = @(x) findiff_Hess(f, x, sqrt(h), adapt);
        case 'Jfw'
            % OVERWRITE Hessf WITH F. HANDLE THAT USES findiff_J
            % [with option 'Jfw']
            Hessf = @(x) findiff_J(gradf, x, h, 'Jfw', true, adapt);
        case 'Jc'
            % OVERWRITE Hessf WITH F. HANDLE THAT USES findiff_J
            % [with option 'Jc']
            Hessf = @(x) findiff_J(gradf, x, h, 'Jc', true, adapt);
    end
end


if isequal(FDHess, 'MF') && use_Hess_sparsity
    error(['Cannot use a matrix-free method if the parameter ' ...
        'use_Hess_sparsity is set to true.'])
end

% Initialization
xk = x0;
fk = f(x0);
gradfk = gradf(xk);

xseq = 0;
%xseq = zeros(length(x0), kmax); % cannot build such sequence when
%length(x0) is too large (not enough space in memory)
btseq = zeros(1, kmax);
pcg_iterseq = zeros(1, kmax);

gradfk_norm = norm(gradfk);
bcktrck_fail = false;

k = 0;

farmijo = @(fk, alpha, c1_gradfk_pk) ...
    fk + alpha * c1_gradfk_pk;

while k < kmax && gradfk_norm > tolgrad
    
    % Compute the descent direction as solution of
    % Hessf(xk) p = - gradf(xk)

    switch FDHess
        case 'MF'
            % Matrix-free implementation
            switch adapt
                case false
                    Hessfk_pk = @(p) (gradf(xk + h * p) - gradfk) / h;
                case true
                    step = h * abs(xk);
                    step(step < 1e-12) = h;
                    Hessfk_pk = @(p) (gradf(xk + step .* p) - gradfk) ./ step;
            end
            fterms_k = fterms(k + 1, gradfk_norm);
            [pk, pcg_iterseq(k + 1)] = ...
                    cg_curvature_condition(Hessfk_pk, -gradfk,...
                        pcg_maxit, fterms_k);
            if any(isnan(pk)) || any(isinf(pk))
                break;
            end
        otherwise
            % Initialization
            Hessfk = Hessf(xk);
            fterms_k = fterms(k + 1, gradfk_norm);
            try
                %Try to compute L
                L = ichol(Hessfk);
                [pk, pcg_iterseq(k + 1)] = ...
                    pcg_curvature_condition(@(x) Hessfk * x,  ...
                        -gradfk, pcg_maxit, fterms_k, L, L');
                %disp('SUCCESS')
            catch ME
                % If ichol fails, proceed without preconditioning
                %disp('fail')
                [pk, pcg_iterseq(k + 1)] = ...
                    cg_curvature_condition(@(x) Hessfk * x, -gradfk,...
                        pcg_maxit, fterms_k);
            end
    end

    % Backtracking

    alpha = 1;
    bt = 0;
    
    xnew = xk + alpha * pk;
    fnew = f(xnew);

    c1_gradfk_pk = c1 * gradfk' * pk;

    while bt < btmax && fnew > farmijo(fk, alpha, c1_gradfk_pk)
        alpha = rho * alpha;
        xnew = xk + alpha * pk;
        fnew = f(xnew);
        bt = bt + 1;
    end
    
    if bt == btmax && fnew > farmijo(fk, alpha, c1_gradfk_pk)
        disp('Backtracking strategy could not find a suitable steplength');
        bcktrck_fail = true;
        break
    end
    
    xk = xnew;
    fk = fnew;
    gradfk = gradf(xk);
    gradfk_norm = norm(gradfk);
    k = k + 1;

    %xseq(:, k) = xk;
    
    btseq(k) = bt;

end

flag = ['Procedure stopped in ', num2str(k), ... 
    ' steps, with gradient norm ', num2str(gradfk_norm)];
%xseq = xseq(:, 1:k);
%xseq = [x0, xseq];
btseq = btseq(1:k);
pcg_iterseq = pcg_iterseq(1:k);
pcg_iterseq_mean = mean(pcg_iterseq);

end

